.\" Automatically generated by Pandoc 2.11.4
.\"
.TH "al_check_inverse" "3" "" "Allegro reference manual" ""
.hy
.SH NAME
.PP
al_check_inverse - Allegro 5 API
.SH SYNOPSIS
.IP
.nf
\f[C]
#include <allegro5/allegro.h>

int al_check_inverse(const ALLEGRO_TRANSFORM *trans, float tol)
\f[R]
.fi
.SH DESCRIPTION
.PP
Checks if the transformation has an inverse using the supplied
tolerance.
Tolerance should be a small value between 0 and 1, with 1e-7 being
sufficient for most applications.
.PP
In this function tolerance specifies how close the determinant can be to
0 (if the determinant is 0, the transformation has no inverse).
Thus the smaller the tolerance you specify, the \[lq]worse\[rq]
transformations will pass this test.
Using a tolerance of 1e-7 will catch errors greater than 1/1000\[cq]s of
a pixel, but let smaller errors pass.
That means that if you transformed a point by a transformation and then
transformed it again by the inverse transformation that passed this
check, the resultant point should less than 1/1000\[cq]s of a pixel away
from the original point.
.PP
Note that this check is superfluous most of the time if you never
touched the transformation matrix values yourself.
The only thing that would cause the transformation to not have an
inverse is if you applied a 0 (or very small) scale to the
transformation or you have a really large translation.
As long as the scale is comfortably above 0, the transformation will be
invertible.
.PP
\f[I]Parameters:\f[R]
.IP \[bu] 2
trans - Transformation to check
.IP \[bu] 2
tol - Tolerance
.PP
\f[I]Returns:\f[R] 1 if the transformation is invertible, 0 otherwise
.RS
.PP
\f[I]Note\f[R]: Allegro\[cq]s transformation inversion functions work
correctly only with 2D transformations.
.RE
.SH SEE ALSO
.PP
al_invert_transform(3)
