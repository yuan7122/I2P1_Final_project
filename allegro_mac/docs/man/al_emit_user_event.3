.\" Automatically generated by Pandoc 2.11.4
.\"
.TH "al_emit_user_event" "3" "" "Allegro reference manual" ""
.hy
.SH NAME
.PP
al_emit_user_event - Allegro 5 API
.SH SYNOPSIS
.IP
.nf
\f[C]
#include <allegro5/allegro.h>

bool al_emit_user_event(ALLEGRO_EVENT_SOURCE *src,
   ALLEGRO_EVENT *event, void (*dtor)(ALLEGRO_USER_EVENT *))
\f[R]
.fi
.SH DESCRIPTION
.PP
Emit an event from a user event source.
The event source must have been initialised with
al_init_user_event_source(3).
Returns \f[C]false\f[R] if the event source isn\[cq]t registered with
any queues, hence the event wouldn\[cq]t have been delivered into any
queues.
.PP
Events are \f[I]copied\f[R] in and out of event queues, so after this
function returns the memory pointed to by \f[C]event\f[R] may be freed
or reused.
Some fields of the event being passed in may be modified by the
function.
.PP
Reference counting will be performed if \f[C]dtor\f[R] is not NULL.
Whenever a copy of the event is made, the reference count increases.
You need to call al_unref_user_event(3) to decrease the reference count
once you are done with a user event that you have received from
al_get_next_event(3), al_peek_next_event(3), al_wait_for_event(3), etc.
.PP
Once the reference count drops to zero \f[C]dtor\f[R] will be called
with a copy of the event as an argument.
It should free the resources associated with the event, but
\f[I]not\f[R] the event itself (since it is just a copy).
.PP
If \f[C]dtor\f[R] is NULL then reference counting will not be performed.
It is safe, but unnecessary, to call al_unref_user_event(3) on
non-reference counted user events.
.PP
You can use al_emit_user_event to emit both user and non-user events
from your user event source.
Note that emitting input events will not update the corresponding input
device states.
For example, you may emit an event of type ALLEGRO_EVENT_KEY_DOWN(3),
but it will not update the ALLEGRO_KEYBOARD_STATE(3) returned by
al_get_keyboard_state(3).
.SH SEE ALSO
.PP
ALLEGRO_USER_EVENT(3), al_unref_user_event(3)
