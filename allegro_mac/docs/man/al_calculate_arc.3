.\" Automatically generated by Pandoc 2.11.4
.\"
.TH "al_calculate_arc" "3" "" "Allegro reference manual" ""
.hy
.SH NAME
.PP
al_calculate_arc - Allegro 5 API
.SH SYNOPSIS
.IP
.nf
\f[C]
#include <allegro5/allegro_primitives.h>

void al_calculate_arc(float* dest, int stride, float cx, float cy,
   float rx, float ry, float start_theta, float delta_theta, float thickness,
   int num_points)
\f[R]
.fi
.SH DESCRIPTION
.PP
When \f[C]thickness <= 0\f[R] this function computes positions of
\f[C]num_points\f[R] regularly spaced points on an elliptical arc.
When \f[C]thickness > 0\f[R] this function computes two sets of points,
obtained as follows: the first set is obtained by taking the points
computed in the \f[C]thickness <= 0\f[R] case and shifting them by
\f[C]thickness / 2\f[R] outward, in a direction perpendicular to the arc
curve.
The second set is the same, but shifted \f[C]thickness / 2\f[R] inward
relative to the arc.
The two sets of points are interleaved in the destination buffer
(i.e.\ the first pair of points will be collinear with the arc center,
the first point of the pair will be farther from the center than the
second point; the next pair will also be collinear, but at a different
angle and so on).
.PP
The destination buffer \f[C]dest\f[R] is interpreted as a set of
regularly spaced pairs of floats, each pair holding the coordinates of
the corresponding point on the arc.
The two floats in the pair are adjacent, and the distance (in bytes)
between the addresses of the first float in two successive pairs is
\f[C]stride\f[R].
For example, if you have a tightly packed array of floats with no spaces
between pairs, then \f[C]stride\f[R] will be exactly
\f[C]2 * sizeof(float)\f[R].
.PP
Example with \f[C]thickness <= 0\f[R]:
.IP
.nf
\f[C]
const int num_points = 4;
float points[num_points][2];
al_calculate_arc(&points[0][0], 2 * sizeof(float), 0, 0, 10, 10, 0, ALLEGRO_PI / 2, 0, num_points);

assert((int)points[0][0] == 10);
assert((int)points[0][1] == 0);

assert((int)points[num_points - 1][0] == 0);
assert((int)points[num_points - 1][1] == 10);
\f[R]
.fi
.PP
Example with \f[C]thickness > 0\f[R]:
.IP
.nf
\f[C]
const int num_points = 4;
float points[num_points * 2][2];
al_calculate_arc(&points[0][0], 2 * sizeof(float), 0, 0, 10, 10, 0, ALLEGRO_PI / 2, 2, num_points);

assert((int)points[0][0] == 11);
assert((int)points[0][1] == 0);
assert((int)points[1][0] == 9);
assert((int)points[1][1] == 0);

assert((int)points[(num_points - 1) * 2][0] == 0);
assert((int)points[(num_points - 1) * 2][1] == 11);
assert((int)points[(num_points - 1) * 2 + 1][0] == 0);
assert((int)points[(num_points - 1) * 2 + 1][1] == 9);
\f[R]
.fi
.PP
\f[I]Parameters:\f[R]
.IP \[bu] 2
dest - The destination buffer
.IP \[bu] 2
stride - Distance (in bytes) between starts of successive pairs of
points
.IP \[bu] 2
cx, cy - Center of the arc
.IP \[bu] 2
rx, ry - Radii of the arc
.IP \[bu] 2
start_theta - The initial angle from which the arc is calculated in
radians
.IP \[bu] 2
delta_theta - Angular span of the arc in radians (pass a negative number
to switch direction)
.IP \[bu] 2
thickness - Thickness of the arc
.IP \[bu] 2
num_points - The number of points to calculate
.SH SEE ALSO
.PP
al_draw_arc(3), al_calculate_spline(3), al_calculate_ribbon(3)
